.prod_template:
  tags: [dagger, prod]
  variables: 
    REPO_BRANCH: main
    HELM_BRANCH: main

.dev_template:
  tags: [dagger, dev]
  variables:
    REPO_BRANCH: develop
    HELM_BRANCH: dev

.dagger:
  image: ghcr.io/purpleclay/dagger-cli:0.18.10
  variables:
    MINIO: s3.waw3-2.cloudferro.com
    BUCKET: registry-eo4eu-umm-database
    GITLAB: git.apps.eo4eu.eu
    REPO_NAMESPACE: eo4eu/eo4eu-umm/user-management-module
    HELM_NAMESPACE: eo4eu/eo4eu-cicd/cicd-infra
    REGISTRY: registry.apps.eo4eu.eu
    REPO: umm-database
    HELM: helm-repo
    SERVICE: eo4eu-umm
    CONTEXT: build
  before_script:
    - "apk --no-cache add wget"
    - "export VAULT_TOKEN=$(wget -qO- --method=PUT \
      --body-data='{\"role_id\":\"'\"$VAULT_ROLE_ID\"'\",\"secret_id\":\"'\"$VAULT_SECRET_ID\"'\"}' \
      \"$VAULT_SERVER_URL/v1/auth/approle/login\" | jq -r '.auth.client_token')"
    - "export BEARER=\"X-Vault-Token: $VAULT_TOKEN\""
    - "export CI_REPO_USERNAME=$(wget -qO- --header=\"$BEARER\" \
      \"$VAULT_SERVER_URL/v1/kv/data/eo4eu-cicd/gitlab_credentials/$SERVICE/$REPO\" | \
      jq -r '.data.data.username')"
    - "export CI_REPO_PASSWORD=$(wget -qO- --header=\"$BEARER\" \
      \"$VAULT_SERVER_URL/v1/kv/data/eo4eu-cicd/gitlab_credentials/$SERVICE/$REPO\" | \
      jq -r '.data.data.password')"
    - "export CI_COOKIECUTTER_USERNAME=$(wget -qO- --header=\"$BEARER\" \
      \"$VAULT_SERVER_URL/v1/kv/data/gitlab_credentials/cookiecutter-repo\" | \
      jq -r '.data.data.username')"
    - "export CI_COOKIECUTTER_PASSWORD=$(wget -qO- --header=\"$BEARER\" \
      \"$VAULT_SERVER_URL/v1/kv/data/gitlab_credentials/cookiecutter-repo\" | \
      jq -r '.data.data.password')"
    - "export CI_HELM_USERNAME=$(wget -qO- --header=\"$BEARER\" \
      \"$VAULT_SERVER_URL/v1/kv/data/gitlab_credentials/$HELM\" | \
      jq -r '.data.data.username')"
    - "export CI_HELM_PASSWORD=$(wget -qO- --header=\"$BEARER\" \
      \"$VAULT_SERVER_URL/v1/kv/data/gitlab_credentials/$HELM\" | \
      jq -r '.data.data.password')"
    - "export S3_ACCESS_KEY=$(wget -qO- --header=\"$BEARER\" \
      \"$VAULT_SERVER_URL/v1/kv/data/s3_cloudferro_creds/gitlab\" | \
      jq -r '.data.data.s3_access_key')"
    - "export S3_SECRET_KEY=$(wget -qO- --header=\"$BEARER\" \
      \"$VAULT_SERVER_URL/v1/kv/data/s3_cloudferro_creds/gitlab\" | \
      jq -r '.data.data.s3_secret_key')"
    - "export CI_ESO_USERNAME=$(wget -qO- --header=\"$BEARER\" \
      \"$VAULT_SERVER_URL/v1/kv/data/gitlab_credentials/external-secrets-repo\" | \
      jq -r '.data.data.username')"
    - "export CI_ESO_PASSWORD=$(wget -qO- --header=\"$BEARER\" \
      \"$VAULT_SERVER_URL/v1/kv/data/gitlab_credentials/external-secrets-repo\" | \
      jq -r '.data.data.password')"
    - "git clone -b $REPO_BRANCH \
      https://$CI_REPO_USERNAME:$CI_REPO_PASSWORD@$GITLAB/$REPO_NAMESPACE/$REPO.git"
    - "git clone -b $HELM_BRANCH \
      https://$CI_HELM_USERNAME:$CI_HELM_PASSWORD@$GITLAB/$HELM_NAMESPACE/$HELM.git"
    - "export TAG=$(git -C $REPO rev-parse HEAD)"
    - "export BUILD_BLACKLISTED_IMAGES=()"
    - "export SCAN_BLACKLISTED_IMAGES=()"
build_image_prod:
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - when: never
  extends: [.dagger, .prod_template]
  stage: build
  script:
    - cd $REPO
    - |
      if git diff --name-only HEAD~1 | grep -Eq '^('$CONTEXT'/)'; then
        dagger call build \
        --bucket $BUCKET \
        --endpoint https://$MINIO \
        --access env:S3_ACCESS_KEY \
        --secret env:S3_SECRET_KEY \
        --repo $REPO \
        --tag $TAG \
        --dockerfile Dockerfile \
        --passwd env:PGPASSWD \
        --wkd $CONTEXT
      fi
scan_image_prod:
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - when: never
  extends: [.dagger, .prod_template]
  stage: test
  needs: [build_image_prod]
  script:
    - cd $REPO
    - |
      if git diff --name-only HEAD~1 | grep -Eq '^('$CONTEXT'/)'; then
        dagger call scan \
        --bucket $BUCKET \
        --endpoint https://$MINIO \
        --access env:S3_ACCESS_KEY \
        --secret env:S3_SECRET_KEY \
        --severity UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL \
        --exit 0 \
        --repo $REPO \
        --tag $TAG \
        --wkd /builds/$REPO_NAMESPACE/$REPO \
        export \
        --path \
        /builds/$REPO_NAMESPACE/$REPO/vulnerabilities.html
        dagger call sbom \
        --bucket $BUCKET \
        --endpoint https://$MINIO \
        --access env:S3_ACCESS_KEY \
        --secret env:S3_SECRET_KEY \
        --repo $REPO \
        --tag $TAG \
        --wkd /builds/$REPO_NAMESPACE/$REPO \
        export \
        --path \
        /builds/$REPO_NAMESPACE/$REPO/sbom-report.cdx.json
        dagger call scan \
        --bucket $BUCKET \
        --endpoint https://$MINIO \
        --access env:S3_ACCESS_KEY \
        --secret env:S3_SECRET_KEY \
        --severity CRITICAL \
        --exit 0 \
        --repo $REPO \
        --tag $TAG \
        --wkd /builds/$REPO_NAMESPACE/$REPO
      fi
  artifacts:
    when: always
    expire_in: 4 weeks
    paths:
      - vulnerabilities.html
      - sbom-report.cdx.json
cleanup_test_prod:
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - when: never
  extends: [.dagger, .prod_template]
  stage: test
  needs: [scan_image_prod]
  script:
    - cd $REPO
    - |
      export CHART=$(grep 'chart_name:' cookiecutter-config.yaml | \
        awk '{print $2}' | tr -d '"')
    - |
      export NAMESPACE=$(grep 'chart_namespace:' cookiecutter-config.yaml | \
        awk '{print $2}' | tr -d '"')
    - |
      if git diff --name-only HEAD~1 | grep -Eq '^('$CONTEXT'/)'; then
        dagger call delete --name "${REPO}-${REPO_BRANCH}" \
        --chart $CHART \
        --namespace $NAMESPACE || true
      fi
test_app_prod:
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - when: never
  extends: [.dagger, .prod_template]
  stage: test
  needs: [cleanup_test_prod]
  script:
    - cd $REPO
    - |
      export CHART=$(grep 'chart_name:' cookiecutter-config.yaml | \
        awk '{print $2}' | tr -d '"')
    - |
      export NAMESPACE=$(grep 'chart_namespace:' cookiecutter-config.yaml | \
        awk '{print $2}' | tr -d '"')
    - |
      if git diff --name-only HEAD~1 | grep -Eq '^('$CONTEXT'/)'; then
        dagger call test --name "${REPO}-${REPO_BRANCH}" \
        --bucket $BUCKET \
        --endpoint https://$MINIO \
        --access env:S3_ACCESS_KEY \
        --secret env:S3_SECRET_KEY \
        --gitlab $GITLAB \
        --chart $CHART \
        --namespace $NAMESPACE \
        --branch $REPO \
        --repo $REPO \
        --tag $TAG \
        --username $CI_COOKIECUTTER_USERNAME \
        --password env:CI_COOKIECUTTER_PASSWORD \
        --user $CI_ESO_USERNAME \
        --pwd env:CI_ESO_PASSWORD \
        --wkd $PWD
      fi
push_image_prod:
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - when: never
  extends: [.dagger, .prod_template]
  stage: deploy
  needs: [test_app_prod]
  script:
    - cd $REPO
    - |
      if git diff --name-only HEAD~1 | grep -Eq '^('$CONTEXT'/)'; then
        dagger call push \
          --bucket $BUCKET \
          --endpoint https://$MINIO \
          --access env:S3_ACCESS_KEY \
          --secret env:S3_SECRET_KEY \
          --registry $REGISTRY \
          --namespace $REPO_NAMESPACE \
          --repo $REPO \
          --srctag $TAG \
          --dsttag $TAG \
          --username $CI_REPO_USERNAME \
          --password env:CI_REPO_PASSWORD \
          --wkd $CONTEXT
      fi
update_helm_prod:
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - when: never
  extends: [.dagger, .prod_template]
  stage: deploy
  needs: [push_image_prod]
  artifacts:
    untracked: true
  script:
    - cd $REPO
    - |
      if git diff --name-only HEAD~1 | grep -Eq '^('$CONTEXT'/)'; then
        sed -i 's/\(  statefulset_image_tag: "\)\(.*\)/\1'"$TAG"'"/g' \
          cookiecutter-config.yaml
        git config user.email "federico.fornari@ecmwf.int"
        git config user.name "Cookiecutter"
        git add --all
        git commit -m "Updated image tag by Cookiecutter" || true
        git push -o ci.skip
      fi
    - dagger call update
      --gitlab $GITLAB
      --repo $REPO
      --username $CI_COOKIECUTTER_USERNAME
      --password env:CI_COOKIECUTTER_PASSWORD
      --wkd .
      export
      --path
      /builds/$REPO_NAMESPACE/$REPO/$REPO-helm
sync_helm_prod:
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - when: never
  extends: [.dagger, .prod_template]
  stage: deploy
  needs: [update_helm_prod]
  dependencies: [update_helm_prod]
  artifacts:
    untracked: true
  script:
    - rm -rf $HELM/$REPO
    - cp -r /builds/$REPO_NAMESPACE/$REPO/$REPO-helm $HELM/$REPO
    - cd $HELM
    - git config user.email "federico.fornari@ecmwf.int"
    - git config user.name "Cookiecutter"
    - git add --all
    - git commit -m "Updated helm chart by Cookiecutter" || true
    - git push
clean_registry_prod:
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - when: never
  extends: [.dagger, .prod_template]
  stage: .post
  script:
    - cd $REPO
    - |
      if git diff --name-only HEAD~1 | grep -Eq '^('$CONTEXT'/)'; then
        dagger call clean \
        --bucket $BUCKET \
        --endpoint https://$MINIO \
        --access env:S3_ACCESS_KEY \
        --secret env:S3_SECRET_KEY
      fi
build_image_dev:
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
    - when: never
  extends: [.dagger, .dev_template]
  stage: build
  script:
    - cd $REPO
    - |
      if git diff --name-only HEAD~1 | grep -Eq '^('$CONTEXT'/)'; then
        dagger call build \
        --bucket $BUCKET \
        --endpoint https://$MINIO \
        --access env:S3_ACCESS_KEY \
        --secret env:S3_SECRET_KEY \
        --repo $REPO \
        --tag $TAG \
        --dockerfile Dockerfile \
        --passwd env:PGPASSWD \
        --wkd $CONTEXT
      fi
scan_fix_image_dev:
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
    - when: never
  extends: [.dagger, .dev_template]
  stage: test
  needs: [build_image_dev]
  script:
    - cd $REPO
    - |
      if git diff --name-only HEAD~1 | grep -Eq '^('$CONTEXT'/)'; then
        dagger call scan \
          --bucket $BUCKET \
          --endpoint https://$MINIO \
          --access env:S3_ACCESS_KEY \
          --secret env:S3_SECRET_KEY \
          --severity CRITICAL \
          --exit 0 \
          --repo $REPO \
          --tag $TAG \
          --wkd /builds/$REPO_NAMESPACE/$REPO \
          export \
          --path \
          /builds/$REPO_NAMESPACE/$REPO/vulnerabilities.html
        while grep -q 'class="severity-CRITICAL"' \
              /builds/$REPO_NAMESPACE/$REPO/vulnerabilities.html; do
          if ((${#BUILD_BLACKLISTED_IMAGES[@]})); then
            eval BUILD_BLACKLISTED_IMAGES=($(printf "%q\n" "${BUILD_BLACKLISTED_IMAGES[@]}" | sort -u))
            fix_cmd="dagger call fix \
              --bucket \$BUCKET \
              --endpoint https://\$MINIO \
              --access env:S3_ACCESS_KEY \
              --secret env:S3_SECRET_KEY \
              --repo \$REPO \
              --tag \$TAG \
              --severity CRITICAL \
              --blbuild \$build_blacklist \
              --blscan \$scan_blacklist \
              --wkd /builds/\$REPO_NAMESPACE/\$REPO/\$CONTEXT \
              export \
              --path \
              /builds/\$REPO_NAMESPACE/\$REPO/\$CONTEXT/Dockerfile.updated"
          else
            fix_cmd="dagger call fix \
              --bucket \$BUCKET \
              --endpoint https://\$MINIO \
              --access env:S3_ACCESS_KEY \
              --secret env:S3_SECRET_KEY \
              --repo \$REPO \
              --tag \$TAG \
              --severity CRITICAL \
              --blscan \$scan_blacklist \
              --wkd /builds/\$REPO_NAMESPACE/\$REPO/\$CONTEXT \
              export \
              --path \
              /builds/\$REPO_NAMESPACE/\$REPO/\$CONTEXT/Dockerfile.updated"
          fi
          if ((${#SCAN_BLACKLISTED_IMAGES[@]})); then
            eval SCAN_BLACKLISTED_IMAGES=($(printf "%q\n" "${SCAN_BLACKLISTED_IMAGES[@]}" | sort -u))
          else
            SCAN_BLACKLISTED_IMAGES+=($(sed -n 's/^FROM[[:space:]]\+\([^[:space:]]\+\).*$/\1/p' \
            /builds/$REPO_NAMESPACE/$REPO/$CONTEXT/Dockerfile))
          fi
          build_blacklist=$(printf "%s," "${BUILD_BLACKLISTED_IMAGES[@]/$'\r'/}")
          build_blacklist=${build_blacklist%,}
          scan_blacklist=$(printf "%s," "${SCAN_BLACKLISTED_IMAGES[@]/$'\r'/}")
          scan_blacklist=${scan_blacklist%,}
          if eval $fix_cmd; then
            if ! diff /builds/$REPO_NAMESPACE/$REPO/$CONTEXT/Dockerfile \
                      /builds/$REPO_NAMESPACE/$REPO/$CONTEXT/Dockerfile.updated; then
              if dagger call build \
                    --bucket $BUCKET \
                    --endpoint https://$MINIO \
                    --access env:S3_ACCESS_KEY \
                    --secret env:S3_SECRET_KEY \
                    --repo $REPO \
                    --tag hardened \
                    --dockerfile Dockerfile.updated \
                    --passwd env:PGPASSWD \
                    --wkd /builds/$REPO_NAMESPACE/$REPO/$CONTEXT; then
                if ! dagger call scan \
                      --bucket $BUCKET \
                      --endpoint https://$MINIO \
                      --access env:S3_ACCESS_KEY \
                      --secret env:S3_SECRET_KEY \
                      --severity CRITICAL \
                      --exit 0 \
                      --repo $REPO \
                      --tag hardened \
                      --wkd /builds/$REPO_NAMESPACE/$REPO/$CONTEXT \
                      export \
                      --path \
                      /builds/$REPO_NAMESPACE/$REPO/vulnerabilities.html; then
                  echo "Continuing because scan failed"
                elif grep -q 'class="severity-CRITICAL"' \
                     /builds/$REPO_NAMESPACE/$REPO/vulnerabilities.html; then
                  SCAN_BLACKLISTED_IMAGES+=($(sed -n 's/^FROM[[:space:]]\+\([^[:space:]]\+\).*$/\1/p' \
                  /builds/$REPO_NAMESPACE/$REPO/$CONTEXT/Dockerfile.updated))
                else
                  echo "Hardened image successfully created"
                fi
              else
                echo "Skipping scan because build failed"
                BUILD_BLACKLISTED_IMAGES+=($(sed -n 's/^FROM[[:space:]]\+\([^[:space:]]\+\).*$/\1/p' \
                /builds/$REPO_NAMESPACE/$REPO/$CONTEXT/Dockerfile.updated))
              fi
            else
              echo "Continuing because LLM call failed"
            fi
          else
            echo "Continuing because LLM call failed"
          fi          
        done
      fi
      if [ ! -f /builds/$REPO_NAMESPACE/$REPO/$CONTEXT/Dockerfile.updated ]; then
        cp /builds/$REPO_NAMESPACE/$REPO/$CONTEXT/Dockerfile \
           /builds/$REPO_NAMESPACE/$REPO/$CONTEXT/Dockerfile.updated
      fi
  artifacts:
    when: always
    expire_in: 4 weeks
    paths:
      - /builds/$REPO_NAMESPACE/$REPO/$CONTEXT/Dockerfile.updated
report_image_dev:
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
    - when: never
  extends: [.dagger, .dev_template]
  stage: test
  needs: [scan_fix_image_dev]
  script:
    - cd $REPO
    - |
      if git diff --name-only HEAD~1 | grep -Eq '^('$CONTEXT'/)'; then
        dagger call scan \
          --bucket $BUCKET \
          --endpoint https://$MINIO \
          --access env:S3_ACCESS_KEY \
          --secret env:S3_SECRET_KEY \
          --severity UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL \
          --exit 0 \
          --repo $REPO \
          --tag $TAG \
          --wkd /builds/$REPO_NAMESPACE/$REPO \
          export \
          --path \
          /builds/$REPO_NAMESPACE/$REPO/vulnerabilities.html
        dagger call sbom \
          --bucket $BUCKET \
          --endpoint https://$MINIO \
          --access env:S3_ACCESS_KEY \
          --secret env:S3_SECRET_KEY \
          --repo $REPO \
          --tag $TAG \
          --wkd /builds/$REPO_NAMESPACE/$REPO \
          export \
          --path \
          /builds/$REPO_NAMESPACE/$REPO/sbom-report.cdx.json
      fi
  artifacts:
    when: always
    expire_in: 4 weeks
    paths:
      - vulnerabilities.html
      - sbom-report.cdx.json
cleanup_test_dev:
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
    - when: never
  extends: [.dagger, .dev_template]
  stage: test
  needs: [report_image_dev]
  script:
    - cd $REPO
    - |
      export CHART=$(grep 'chart_name:' cookiecutter-config.yaml | \
        awk '{print $2}' | tr -d '"')
    - |
      export NAMESPACE=$(grep 'chart_namespace:' cookiecutter-config.yaml | \
        awk '{print $2}' | tr -d '"')
    - |
      if git diff --name-only HEAD~1 | grep -Eq '^('$CONTEXT'/)'; then
        dagger call delete --name "${REPO}-${REPO_BRANCH}" \
        --chart $CHART \
        --namespace $NAMESPACE || true
      fi
test_app_dev:
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
    - when: never
  extends: [.dagger, .dev_template]
  stage: test
  needs: [cleanup_test_dev,scan_fix_image_dev]
  dependencies: [scan_fix_image_dev]
  artifacts:
    untracked: true
  script:
    - cd $REPO
    - |
      if ! diff $CONTEXT/Dockerfile \
          /builds/$REPO_NAMESPACE/$REPO/$CONTEXT/Dockerfile.updated; then
        export TAG=hardened
      fi
    - |
      export CHART=$(grep 'chart_name:' cookiecutter-config.yaml | \
        awk '{print $2}' | tr -d '"')
    - |
      export NAMESPACE=$(grep 'chart_namespace:' cookiecutter-config.yaml | \
        awk '{print $2}' | tr -d '"')
    - |
      if git diff --name-only HEAD~1 | grep -Eq '^('$CONTEXT'/)'; then
        dagger call test --name "${REPO}-${REPO_BRANCH}" \
        --bucket $BUCKET \
        --endpoint https://$MINIO \
        --access env:S3_ACCESS_KEY \
        --secret env:S3_SECRET_KEY \
        --gitlab $GITLAB \
        --chart $CHART \
        --namespace $NAMESPACE \
        --branch $REPO \
        --repo $REPO \
        --tag $TAG \
        --username $CI_COOKIECUTTER_USERNAME \
        --password env:CI_COOKIECUTTER_PASSWORD \
        --user $CI_ESO_USERNAME \
        --pwd env:CI_ESO_PASSWORD \
        --wkd $PWD
      fi
push_image_dev:
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
    - when: never
  extends: [.dagger, .dev_template]
  stage: deploy
  needs: [test_app_dev,scan_fix_image_dev]
  dependencies: [scan_fix_image_dev]
  artifacts:
    untracked: true
  script:
    - cd $REPO
    - |
      if ! diff $CONTEXT/Dockerfile \
          /builds/$REPO_NAMESPACE/$REPO/$CONTEXT/Dockerfile.updated; then
        export SRC_TAG=hardened
      else
        export SRC_TAG=$TAG
      fi
    - |
      if git diff --name-only HEAD~1 | grep -Eq '^('$CONTEXT'/)'; then
        dagger call push \
          --bucket $BUCKET \
          --endpoint https://$MINIO \
          --access env:S3_ACCESS_KEY \
          --secret env:S3_SECRET_KEY \
          --registry $REGISTRY \
          --namespace $REPO_NAMESPACE \
          --repo $REPO \
          --srctag $SRC_TAG \
          --dsttag $TAG \
          --username $CI_REPO_USERNAME \
          --password env:CI_REPO_PASSWORD \
          --wkd $CONTEXT
      fi
harden_dockerfile_dev:
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
    - when: never
  extends: [.dagger, .dev_template]
  stage: deploy
  needs: [push_image_dev,scan_fix_image_dev]
  dependencies: [scan_fix_image_dev]
  artifacts:
    untracked: true
  script:
    - |
      if ! diff $REPO/$CONTEXT/Dockerfile \
           /builds/$REPO_NAMESPACE/$REPO/$CONTEXT/Dockerfile.updated; then
        cp /builds/$REPO_NAMESPACE/$REPO/$CONTEXT/Dockerfile.updated \
           $REPO/$CONTEXT/Dockerfile
        cd $REPO
        if git diff --name-only HEAD~1 | grep -Eq '^('$CONTEXT'/)'; then
          git config user.email "federico.fornari@ecmwf.int"
          git config user.name "Security Agent"
          git add --all
          git commit -m "Hardened Dockerfile by Security Agent" || true
          git push -o ci.skip
        fi
      fi
update_helm_dev:
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
    - when: never
  extends: [.dagger, .dev_template]
  stage: deploy
  needs: [harden_dockerfile_dev]
  artifacts:
    untracked: true
  script:
    - cd $REPO
    - |
      if git diff --name-only HEAD~1 | grep -Eq '^('$CONTEXT'/)'; then
        sed -i 's/\(  statefulset_image_tag: "\)\(.*\)/\1'"$TAG"'"/g' \
          cookiecutter-config.yaml
        git config user.email "federico.fornari@ecmwf.int"
        git config user.name "Cookiecutter"
        git add --all
        git commit -m "Updated image tag by Cookiecutter" || true
        git push -o ci.skip
      fi
    - dagger call update
      --gitlab $GITLAB
      --repo $REPO
      --username $CI_COOKIECUTTER_USERNAME
      --password env:CI_COOKIECUTTER_PASSWORD
      --wkd .
      export
      --path
      /builds/$REPO_NAMESPACE/$REPO/$REPO-helm
sync_helm_dev:
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
    - when: never
  extends: [.dagger, .dev_template]
  stage: deploy
  needs: [update_helm_dev]
  dependencies: [update_helm_dev]
  artifacts:
    untracked: true
  script:
    - rm -rf $HELM/$REPO
    - cp -r /builds/$REPO_NAMESPACE/$REPO/$REPO-helm $HELM/$REPO
    - cd $HELM
    - git config user.email "federico.fornari@ecmwf.int"
    - git config user.name "Cookiecutter"
    - git add --all
    - git commit -m "Updated helm chart by Cookiecutter" || true
    - git push
clean_registry_dev:
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
    - when: never
  extends: [.dagger, .dev_template]
  stage: .post
  script:
    - cd $REPO
    - |
      if git diff --name-only HEAD~1 | grep -Eq '^('$CONTEXT'/)'; then
        dagger call clean \
        --bucket $BUCKET \
        --endpoint https://$MINIO \
        --access env:S3_ACCESS_KEY \
        --secret env:S3_SECRET_KEY
      fi